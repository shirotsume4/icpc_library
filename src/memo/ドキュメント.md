#使い方のメモ。

## hash
写経をしたときにミスを発見するために使う。空白や改行を消した状態のハッシュを計算して、一致していれば写経成功している　違えばどこかに違う部分があるとわかる
## BIT
- `BIT B(n)` :長さnのBITを作る
- `B.sum(l, r)` :$\sum_{i=l}^{r-1} A_i$ の値を求める。`sum(r)`で0からの和。
## FastSet
std::setより高速。bitsetで要素の存在を管理する。
- `FS S(n)`: 0以上n未満の値を格納できるFSを作る
- `S.set(i)`: iを挿入
- `S.erase(i)`: iを削除
- `S[i]`: iが存在するならtrue,存在しないならfalse
- `next(i)`: iより大きい最小の値
- `prev(i)`: iより小さい最大の値

## Skew-heap
基本的に普通の優先度付きキューと同一。2つのヒープの融合（meld）操作が速い
使わんやろ

## cht
Convex Hull Trick

CHTは次の操作を効率的に行える。初め、空集合 $S$ があるとする。
- $S$ に直線 $y = ax + b$ を追加 $O(1)$
- $x_0$ が与えられる。$S$ に含まれる直線について、$ax_0 + b$ の値をそれぞれ計算したときの最小値/最大値を求める。$O(\log N)$

ただし、最小値を求める際は追加する直線の傾きが単調減少、最大値を求める際は追加する直線の傾きが単調増加である必要がある。それを満たせない場合はLi-chao treeなど他の方法で。

- `CHT<true> C` 最小値を求めるCHTの初期化
- `CHT<false> C` 最大値を求めるCHTの初期化
- `C.add(a, b)` 直線a, bを追加
- `C.query(x)` xが与えられた時の最大値最小値

ところで、xが単調増加/単調減少であることが保証できるなら、query_monotone系を使うことでクエリをO(1)にできる

## hash_map
たぶんunordered_mapでいい　衝突とかあったらこれを使う

## lazy-segtree
遅延セグ木多分ACLと同じ

```
using S = long long;
using F = long long;

S op(S a, S b) { return a + b; }
S e() { return 0; }
S mpp(F f, S x) { return f + x; }
F cmpo(F f1, F f2) { return f1 + f2; }
F id() { return 0; }

int main() {
    int n = 10;
    lazy_segtree<S, op, e, F, mpp, cmpo, id> seg(n);
    seg.apply(0, 5, 10); // 区間 [0, 5) に 10 を加算
    cout << seg.prod(0, 10) << endl; // 全区間の和を計算
    return 0;
}
```