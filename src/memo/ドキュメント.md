#使い方のメモ。

## hash
写経をしたときにミスを発見するために使う。空白や改行を消した状態のハッシュを計算して、一致していれば写経成功している　違えばどこかに違う部分があるとわかる
## BIT
- `BIT B(n)` :長さnのBITを作る
- `B.sum(l, r)` :$\sum_{i=l}^{r-1} A_i$ の値を求める。`sum(r)`で0からの和。
## FastSet
std::setより高速。bitsetで要素の存在を管理する。
- `FS S(n)`: 0以上n未満の値を格納できるFSを作る
- `S.set(i)`: iを挿入
- `S.erase(i)`: iを削除
- `S[i]`: iが存在するならtrue,存在しないならfalse
- `next(i)`: iより大きい最小の値
- `prev(i)`: iより小さい最大の値

## Skew-heap
基本的に普通の優先度付きキューと同一。2つのヒープの融合（meld）操作が速い
使わんやろ

## cht
Convex Hull Trick

CHTは次の操作を効率的に行える。初め、空集合 $S$ があるとする。
- $S$ に直線 $y = ax + b$ を追加 $O(1)$
- $x_0$ が与えられる。$S$ に含まれる直線について、$ax_0 + b$ の値をそれぞれ計算したときの最小値/最大値を求める。$O(\log N)$

ただし、最小値を求める際は追加する直線の傾きが単調減少、最大値を求める際は追加する直線の傾きが単調増加である必要がある。それを満たせない場合はLi-chao treeなど他の方法で。

- `CHT<true> C` 最小値を求めるCHTの初期化
- `CHT<false> C` 最大値を求めるCHTの初期化
- `C.add(a, b)` 直線a, bを追加
- `C.query(x)` xが与えられた時の最大値最小値

ところで、xが単調増加/単調減少であることが保証できるなら、query_monotone系を使うことでクエリをO(1)にできる

## hash_map
たぶんunordered_mapでいい　衝突とかあったらこれを使う

## lazy-segtree
遅延セグ木多分ACLと同じ

```
using S = long long;
using F = long long;

S op(S a, S b) { return a + b; }
S e() { return 0; }
S mpp(F f, S x) { return f + x; }
F cmpo(F f1, F f2) { return f1 + f2; }
F id() { return 0; }

int main() {
    int n = 10;
    lazy_segtree<S, op, e, F, mpp, cmpo, id> seg(n);
    seg.apply(0, 5, 10); // 区間 [0, 5) に 10 を加算
    cout << seg.prod(0, 10) << endl; // 全区間の和を計算
    return 0;
}
```

## Li-chao tree

CHTの一般化

- 直線 $y = ax + b$ の追加
- 線分 $y = ax + b (l \leq x \lt r)$ の追加
- 与えられた $x$ に対する最小値の出力

$x$ の値は初期化時にわかっている必要がある。クエリ先読みなどしておく
最大値にしたいときは(a, b)を入れる代わりに(-a, -b)を入れて最小値に-1を掛ければよい

```
vector<ll> xs = {1, 2, 3, 4, 5}; // x 座標の定義
lctree tree(xs);

// 直線追加
tree.update(2, 3); // y = 2x + 3
tree.update(-1, 6); // y = -x + 6

// 範囲に直線を追加
tree.update_segment(1, 4, 3, 2); // 範囲 [1, 4) に y = 3x + 2 を適用

// クエリ
cout << tree.query(2) << endl; // x = 2 における最小値
cout << tree.query(4) << endl; // x = 4 における最小値

```

## line_container

Li-chao treeと違って線分は突っ込めない

```
LineContainer<> lc;  // 最小値を求める直線集合

// 直線を追加
lc.add(2, 3);        // y = 2x + 3
lc.add(-1, 5);       // y = -x + 5
lc.add(1, -4);       // y = x - 4

// クエリ
cout << lc.query(1) << endl;  // x = 1 における最小値を出力
cout << lc.query(3) << endl;  // x = 3 における最小値を出力

// 最大値を求める場合
LineContainer<false> max_lc;
max_lc.add(2, 3);       // y = 2x + 3
max_lc.add(-1, 5);      // y = -x + 5
max_lc.add(1, -4);      // y = x - 4

cout << max_lc.query(1) << endl;  // x = 1 における最大値を出力
cout << max_lc.query(3) << endl;  // x = 3 における最大値を出力
```

## link-cut
知らん　木に関するクエリができる

## pbds
C++のデータ構造拡張パックらしい

## segbeats.hpp

Angel Beats!

遅延セグ木の上位互換　ただし計算量がア

普通の遅延セグ木で解けなかった場合これでワンチャンかけてもいいかも

## segtree-2d

2次元セグ木

## segtree

セグ木 ACLと一緒

```
// 例: セグメント木で区間和を求める
int op(int a, int b) { return a + b; }
int e() { return 0; }  // 単位元

vector<int> v = {1, 2, 3, 4, 5};
segtree<int, op, e> seg(v);

cout << seg.prod(1, 4);  // 区間 [1, 4) の和を出力 (2 + 3 + 4)
```

## swag

Shirotsumeの推しデータ構造です かわいいね

